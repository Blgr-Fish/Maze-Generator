from math import *
#from Maze_Generator import *

from turtle import *

def turtle_truc(n,G):
    setworldcoordinates(0, 0, n, n)
    speed(10) 
    pensize(10)
    maze_completed = False
    
    etape = 0
    key_list = list(G.keys())
    val_list = list(G.values())
    print(len(key_list))
    print(val_list)
    longueur = n

    while maze_completed == False:
        while etape == 0 : # on  définit les contours du labyrinthe
            pd()
            forward(longueur)
            left(90)
            
  
        
        
            if abs(pos()) < 1 :
                etape +=1
                

        while etape == 1 : # on créé les parois intérieurs du labyrinthe
            for i in range(int(n)):
                setx(0)
                sety(0)
                setheading(0)
                forward(i)
                left(90)
                forward(n)
            for j in range (int(n)) :
                setx(0)
                sety(0)
                setheading(90)
                forward(j)
                right(90)
                forward(n)
            etape += 1
                   
               
        while etape == 2 :
            print('b')    
            print(key_list)
            print("b")
            print(val_list)
            for i in range(len(G)):
                for j in range(len(G)):
                    if key_list[i] in val_list[j]:
                        pencolor('white')
                       
                        if key_list[i][0] == key_list[j][0] and key_list[i][1] != key_list[j][1]: # on vérifie que l'index 0 soit le même et que l'index 1 soit différent
                                                                                                  # On efface donc le trait de manière verticale
                            if key_list[i][0] == n-1 and n > 2 : # si on est tout en haut du labyrinthe
                               
                                pu()
                                setpos(max(key_list[i][1],key_list[j][1]),key_list[j][0]+1) # au lieu de tracer un trait vers le haut, on le fait aller vers le bas
                                setheading(270)
                                pd()
                                forward(1)

                            else :
                            
                                pu()
                                setpos(max(key_list[i][1],key_list[j][1]),key_list[j][0])
                                setheading(90)
                                pd()
                                forward(1)
                        
                        
                        elif key_list[i][1] == key_list[j][1] and key_list[i][0] != key_list[j][0]: # Pareil qu'au desssus mais cette fois si c'est pour les index 1
                        
                            if key_list[i][1] == n-1 and n > 2 : # si on est trop à droite
                                                                 # on efface un trait vers la gauche au lieu de la droie
                                pu()
                                setpos(key_list[j][1]+1,max(key_list[i][0],key_list[j][0]))
                                setheading(180)
                                pd()
                                forward(1)

                            else :
                           
                                pu()
                                setpos(key_list[j][1],max(key_list[i][0],key_list[j][0]))
                                setheading(0)
                                pd()
                                forward(1)

                        print(key_list[i],"est relié à ", key_list[j])
                        
            pu()
            setpos(0,0) # quand tout est fini, on revient point de départ
            setheading(0)
            etape += 1

            while etape == 3 : # on remet bien les murs
                
                pencolor("black")
                pd()
                forward(longueur)
                left(90)

                if abs(pos()) < 1 :
                    etape+=1

            while etape == 4 :
                print('Maze Completed')
                maze_completed = True
                break


        done()
            


cote2 = {(0, 0): [(1, 0)], (0, 1): [(1, 1)], (1, 0): [(1, 1), (0, 0)], (1, 1): [(1, 0), (0, 1)]}          

cote4 = {(0, 0): [(1, 0), (0, 1)], (0, 1): [(0, 2)], (0, 2): [(1, 2), (0, 3)], (0, 3): [], (1, 0): [(2, 0), (0, 0)], (1, 1): [(1, 2)], (1, 2): [(0, 2), (1, 1)], (1, 3): [(2, 3), (0, 3)], (2, 0): [(3, 0)], (2, 1): [(2, 2), (3, 1)], (2, 2): [(2, 1)], (2, 3): [(3, 3)], (3, 0): [(3, 1)], (3, 1): [(2, 1), (3, 2)], (3, 2): [(3, 3)], (3, 3): [(2, 3)]}

cote4x4 = {(0, 0): [(1, 0)], (0, 1): [(0, 0), (0, 2)], (0, 2): [(1, 2), (0, 3)], (0, 3): [], (1, 0): [(0, 0), (1, 1)], (1, 1): [(0, 1), (1, 2)], (1, 2): [(1, 1), (0, 2)], (1, 3): [(1, 2), (0, 3)], (2, 0): [(3, 0), (1, 0)], (2, 1): [(3, 1), (2, 0)], (2, 2): [(2, 1), (3, 2)], (2, 3): [(2, 2), (3, 3), (1, 3)], (3, 0): [(2, 0), (3, 1)], (3, 1): [(3, 2), (3, 0)], (3, 2): [(3, 3), (3, 1)], (3, 3): [(2, 3)]}

cote3 = {(0, 0): [], (0, 1): [], (0, 2): [], (1, 0): [], (1, 1): [], (1, 2): [(2,2)], (2, 0): [], (2, 1): [(2,2)], (2, 2): []}

cotetest = {(0, 0): [(0,1)], (0, 1): [(0,2)], (0, 2): [(0,3)],(0,3):[(1,3)], (1, 0): [(2,0)], (1, 1): [(1,2),(2,1)], (1, 2): [(2,2)],(1,3):[(2,3)], (2, 0): [(2,1),(3,0)], (2, 1): [(3,1)], (2, 2): [(2,3)],(2,3):[(3,3)], (3,0):[],(3,1):[(3,2)],(3,2):[],(3,3): [] }

cote10 ={(0, 0): [(1, 0)], (0, 1): [(0, 2)], (0, 2): [(0, 3)], (0, 3): [(0, 4), (1, 3)], (0, 4): [(0, 5), (0, 3)], (0, 5): [(0, 6), (1, 5)], (0, 6): [(0, 5), (0, 7), (1, 6)], (0, 7): [(1, 7), (0, 8), (0, 6)], (0, 8): [(0, 7), (1, 8)], (0, 9): [(1, 9)], (1, 0): [(2, 0)], (1, 1): [(1, 0), (0, 1)], (1, 2): [(1, 3), (0, 2)], (1, 3): [(1, 4), (1, 2)], (1, 4): [(1, 5), (1, 3)], (1, 5): [(1, 4), (2, 5)], (1, 6): [(1, 5), (1, 7), (0, 6)], (1, 7): [(1, 6), (0, 7)], (1, 8): [(1, 9), (1, 7), (0, 8)], (1, 9): [(0, 9), (2, 9)], (2, 0): [(2, 1)], (2, 1): [(1, 1)], (2, 2): [(2, 3), (1, 2)], (2, 3): [(3, 3)], (2, 4): [(3, 4), (2, 5), (1, 4)], (2, 5): [(2, 4), (2, 6), (1, 5)], (2, 6): [(1, 6)], (2, 7): [(2, 8), 
(2, 6), (3, 7)], (2, 8): [(2, 9), (1, 8)], (2, 9): [(1, 9)], (3, 0): [(4, 0), (2, 0)], (3, 1): [(3, 0)], (3, 2): [(2, 2)], (3, 3): [(4, 3), (2, 3)], (3, 4): [(4, 4), (3, 5), (3, 3)], (3, 5): [(3, 6), (4, 5)], (3, 6): [(3, 7), (4, 6), (2, 6)], (3, 7): [(2, 7), (3, 6)], (3, 8): [(4, 8), (2, 8), (3, 9)], (3, 9): [(4, 9)], (4, 0): [(4, 1)], (4, 1): [(4, 0)], (4, 2): [(4, 1), (3, 2), (5, 2), (4, 3)], (4, 3): [(4, 4), (3, 3), (5, 3)], (4, 4): [(3, 4), (4, 3), (5, 4), (4, 5)], (4, 5): [(4, 4), (3, 5), (4, 6)], (4, 6): [(5, 6), (4, 7), (4, 5), (3, 6)], (4, 7): [(4, 6), (4, 8), (3, 
7)], (4, 8): [(4, 9), (4, 7), (3, 8)], (4, 9): [(3, 9), (4, 8)], (5, 0): [(6, 0), (4, 0)], (5, 1): [(4, 1), (5, 2)], (5, 2): [(5, 1), (4, 2), (5, 3), (6, 2)], (5, 3): [(6, 3), (4, 3)], (5, 4): [(6, 4), (5, 3)], (5, 5): [(5, 6), (6, 
5)], (5, 6): [(5, 5), (4, 6)], (5, 7): [(6, 7), (5, 6), (5, 8)], (5, 8): [(5, 7), (6, 8), (5, 9)], (5, 9): [(5, 8), 
(4, 9)], (6, 0): [(6, 1), (7, 0), (5, 0)], (6, 1): [(5, 1), (6, 2), (7, 1), (6, 0)], (6, 2): [(7, 2), (5, 2), (6, 1)], (6, 3): [(5, 3)], (6, 4): [(6, 3), (5, 4), (6, 5)], (6, 5): [(6, 4), (7, 5), (5, 5)], (6, 6): [(6, 7), (7, 6), (5, 6)], (6, 7): [(5, 7), (6, 8)], (6, 8): [(6, 7), (6, 9), (7, 8)], (6, 9): [(6, 8), (7, 9)], (7, 0): [(7, 1), (8, 0)], (7, 1): [(6, 1), (7, 2)], (7, 2): [(7, 3), (6, 2)], (7, 3): [(6, 3), (7, 4)], (7, 4): [(7, 5), (7, 3), (6, 4), (8, 4)], (7, 5): [(7, 6), (7, 4), (8, 5)], (7, 6): [(6, 6), (8, 6), (7, 5)], (7, 7): [(8, 7), (7, 8)], (7, 8): [(8, 8), (7, 9), (6, 8)], (7, 9): [(7, 8), (8, 9), (6, 9)], (8, 0): [(8, 1), (7, 0)], (8, 1): [(7, 1), (8, 0)], (8, 2): [(8, 3)], (8, 3): [(8, 2), (7, 3), (9, 3), (8, 4)], (8, 4): [(7, 4), (8, 3), (9, 4), (8, 5)], (8, 5): [(8, 6), (7, 5)], (8, 6): [(7, 6), (9, 6), (8, 7)], (8, 7): [(9, 7), (8, 6), (7, 7)], (8, 8): [(7, 8), (9, 8), (8, 7)], (8, 9): [(7, 
9), (9, 9), (8, 8)], (9, 0): [(8, 0), (9, 1)], (9, 1): [(9, 2)], (9, 2): [(9, 1), (8, 2)], (9, 3): [(9, 4), (9, 2)], (9, 4): [(9, 5), (8, 4), (9, 3)], (9, 5): [(8, 5), (9, 6)], (9, 6): [(8, 6), (9, 7), (9, 5)], (9, 7): [(9, 6)], (9, 8): [(9, 7), (9, 9)], (9, 9): [(8, 9)]}


"""A = Graphe_dictionnaire()
A.creer_graphe_nxn(10)
A.fusion_aleatoire()"""

E = {(0, 0): [(0, 1)], (0, 1): [(0, 2), (0, 0), (1, 1)], (0, 2): [(1, 2), (0, 1), (0, 1)], (1, 0): [(2, 0), (2, 0)], (1, 1): [(0, 1), (1, 2), (1, 2)], (1, 2): [(0, 2), (2, 2), (1, 1), (0, 2)], (2, 0): [(2, 1), (2, 1), (1, 0)], (2, 1): [(2, 0), (2, 2)], (2, 2): [(2, 1), (1, 2), (1, 2)]}
print(turtle_truc(sqrt(len(cote10)),cote10))
#print(turtle_truc(sqrt(a),a))